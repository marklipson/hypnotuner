package com.marklipson.musicgen;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.IOException;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.SourceDataLine;

public class WavWriter
{
  public static void writeWavFile( float[] values, float sampleRate, File toFile ) throws IOException
  {
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    DataOutputStream bufOut = new DataOutputStream( buf );
    for (int nv=0; nv < values.length; nv++)
    {
      int vi = levelToInt( values[ nv ] );
      bufOut.writeShort( vi );
    }
    AudioInputStream stream = new AudioInputStream( new ByteArrayInputStream( buf.toByteArray() ), new AudioFormat( sampleRate, 16, 1, true, true ), values.length );
    AudioFileFormat.Type format = AudioFileFormat.Type.WAVE;
    AudioSystem.write( stream, format, toFile );
  }
  public static void writeStereoWavFile( float[] valuesL, float[] valuesR, double sampleRate, File toFile ) throws IOException
  {
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    DataOutputStream bufOut = new DataOutputStream( buf );
    for (int nv=0; nv < valuesL.length; nv++)
    {
      int vL = levelToInt( valuesL[ nv ] );
      int vR = levelToInt( valuesR[ nv ] );
      bufOut.writeShort( vL );
      bufOut.writeShort( vR );
    }
    AudioInputStream stream = new AudioInputStream( new ByteArrayInputStream( buf.toByteArray() ), new AudioFormat( (float)sampleRate, 16, 2, true, true ), valuesL.length );
    AudioFileFormat.Type format = AudioFileFormat.Type.WAVE;
    AudioSystem.write( stream, format, toFile );
  }
  static SourceDataLine getLine( AudioFormat audioFormat ) throws Exception
  {
    SourceDataLine res = null;
    DataLine.Info info = new DataLine.Info( SourceDataLine.class, audioFormat );
    res = (SourceDataLine) AudioSystem.getLine(info);
    res.open(audioFormat);
    return res;
  }
  protected static int levelToInt( double v )
  {
    if (v > 1)
      v = 1;
    if (v < -1)
      v = -1;
    int vi = (int)(v * 32767);
    return vi;
  }

  private static File homeFolder()
  {
    File home = new File( System.getProperty( "user.home" ) );
    File out = new File( home, "Desktop/psychotunes" );
    out.mkdirs();
    return out;
  }
  
  /**
   */
  public static void main_mono( String args[] )
  {
    float[] v = new float[ 80000 ];
    for (int n=0; n < v.length; n++)
    {
      double t = n * 0.03;
      v[n] = (float)( Math.sin( t * 2.1 ) * Math.sin( t * (3 + Math.sin(t/300)) ) );
    }
    try
    {
      File fOut = new File( homeFolder(), "test_mono.wav" );
      writeWavFile( v, 10000, fOut );
      System.out.println( "wrote to " + fOut.getAbsolutePath() );
    }
    catch( IOException x )
    {
      x.printStackTrace();
    }
  }
  
  /**
   * t == 0 to 1  (0 = start, 1 = end)
   * width == duration of fade-in/out, i.e. 0.01
   * return == 0 to 1 (0 = silent, 1 = full volume)
   */
  private static double softenEdges( double t, double width )
  {
    if (t < width)
      return t / width;
    if (t > 1 - width)
      return (1-t)/width;
    return 1;
  }
  
  private static double waveform( double t )
  {
    return Math.sin( t ) * 0.9 + Math.sin( t * 2 ) * 0.06 + Math.sin( t * 3 ) * 0.04;
  }
    
  /**
   * Delta = 0-4Hz, deep sleep
   * Theta = between delta and alpha
   * Alpha = 8-12Hz, meditation / alert with eyes closed (10Hz)
   * Gamma = 25 to 100Hz, 40Hz is typical, 25-40Hz = range generated by buddhist monks focusing on compassion
   * 
   * http://www.oracle.com/technetwork/java/javase/download-137625.html
   */
  public static void main( String args[] )
  {
    try
    {
      // sampling rate, samples per second
      int rate = 44100;
      // output
      Speakers speakers = new Speakers( rate );
      // number of seconds
      int nSeconds = 4;
      int nLoops = 100;
      // main values
      boolean writeToFile = false;
      String altName = "trance10";
      // - left tone
      double fLs[] = { 69 };
      double fL0 = fLs[0];
      double fL = fL0;
      double fL2 = fLs[0];
      // - swing balance back and forth in a cycle lasting this many seconds
      double balanceSwingCycle = 31;
      // - range of frequency delta for right channel
      double lowBeatHz = 28;
      double highBeatHz = 32;
      // - duration of beat variation cycle (seconds)
      double beatCycle = 19;
      // duration of fade-in / fade-out
      double fade_s = 10;
      // how quickly to shift notes
      double noteChange = 0.00005;
  
      // derived values
      double midBeatHz = (lowBeatHz + highBeatHz) / 2;
      double rBeat = highBeatHz - midBeatHz;
      // - multiplier for sample number to get a 1Hz wave
      double dt1 = Math.PI * 2 / rate;
      // values for loop
      // - time values
      double tL = 0, tR = 0;
      // - output values
      float[] vL = new float[ rate * nSeconds ];
      float[] vR = new float[ rate * nSeconds ];
      long n = 0;
      long totalSamples = (long)vL.length * nLoops;
      for (int nLoop=0; nLoop < nLoops; nLoop++)
      {
        for (int index=0; index < vL.length; index++, n++)
        {
          // time for 1Hz
          double t1 = n * dt1;
          // slow variation
          double slowVariation = Math.sin( t1 / beatCycle );
          // base frequency
          fL2 = fLs[ (int)(n * fLs.length / totalSamples) ];
          fL = (fL * (1-noteChange) + fL2 * noteChange);
          tL += fL * dt1;
          double L = waveform( tL );
          double fR = fL + midBeatHz + rBeat * slowVariation;
          tR += fR * dt1;
          double R = waveform( tR );
          // balance 'swing'
          if (true)
          {
            double tB = t1 / balanceSwingCycle;
            double bL = (Math.sin( tB ) + 1) / 2;
            double bR = 1 - bL;
            vL[index] = (float)(L * bL + R * bR);
            vR[index] = (float)(R * bL + L * bR);
          }
          else
          {
            vL[index] = (float)L;
            vR[index] = (float)R;
          }
          // fade in/out
          double t = (double)n / vL.length;
          double w = fade_s / nSeconds;
          double fade = softenEdges( t, w );
          vL[index] *= fade;
          vR[index] *= fade;
        }
        speakers.play( vL, vR );
      }
      if (writeToFile)
      {
        String name = "B" + ((int)fL0) + "_L" + ((int)lowBeatHz) + "_H" + ((int)highBeatHz) + "_C" + ((int)beatCycle) + "_b" + ((int)balanceSwingCycle);
        if (altName != null)
          name = altName;
        File fOut = new File( homeFolder(), name + ".wav" );
        writeStereoWavFile( vL, vR, rate, fOut );
        File fOut2 = new File( fOut.toString() + ".ogg" );
        VorbisEncoder.main( new String[] { fOut.toString(), fOut2.toString() } );
        System.out.println( "wrote to " + fOut.getAbsolutePath() );
      }
    }
    catch( Exception x )
    {
      x.printStackTrace();
    }
    System.exit( 0 );
  }

}
